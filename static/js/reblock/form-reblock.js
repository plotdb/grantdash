// Generated by LiveScript 1.3.0
var slice$ = [].slice;
(function(){
  var animate, reblock, ghost;
  animate = {
    running: false,
    alpha: 4,
    dur: 250,
    box: {},
    init: function(arg$){
      var src, des, cb, ref$, ref1$;
      src = arg$.src, des = arg$.des, cb = arg$.cb;
      if (this.running) {
        return;
      }
      this.src = src;
      this.des = des;
      this.running = true;
      import$(this.box, {
        s1: (ref1$ = {}, ref1$.x = (ref$ = src.getBoundingClientRect()).x, ref1$.y = ref$.y, ref1$.width = ref$.width, ref1$.height = ref$.height, ref1$),
        d1: (ref1$ = {}, ref1$.x = (ref$ = des.getBoundingClientRect()).x, ref1$.y = ref$.y, ref1$.width = ref$.width, ref1$.height = ref$.height, ref1$)
      });
      if (this.box.s1.x === (ref$ = this.box.s1.y) && ref$ === (ref$ = this.box.s1.width) && ref$ === (ref$ = this.box.s1.height) && ref$ === 0) {
        this.box.s1 = this.box.d1;
      }
      cb();
      import$(this.box, {
        s2: (ref1$ = {}, ref1$.x = (ref$ = src.getBoundingClientRect()).x, ref1$.y = ref$.y, ref1$.width = ref$.width, ref1$.height = ref$.height, ref1$),
        d2: (ref1$ = {}, ref1$.x = (ref$ = des.getBoundingClientRect()).x, ref1$.y = ref$.y, ref1$.width = ref$.width, ref1$.height = ref$.height, ref1$)
      });
      return requestAnimationFrame(function(it){
        return animate.handle(it);
      });
    },
    handle: function(t){
      var ref$, a, d, s1, s2, d1, d2, p, x1, y1, x2, y2;
      if (!(this.start != null)) {
        this.start = t;
      }
      ref$ = [this.alpha, this.dur], a = ref$[0], d = ref$[1];
      ref$ = this.box, s1 = ref$.s1, s2 = ref$.s2, d1 = ref$.d1, d2 = ref$.d2;
      p = t = (t - this.start) / d;
      t = 1 - Math.pow(t, a) / (Math.pow(t, a) + Math.pow(1 - t, a));
      ref$ = [(s1.x - s2.x) * t, (s1.y - s2.y) * t], x1 = ref$[0], y1 = ref$[1];
      ref$ = [(d1.x - d2.x) * t, (d1.y - d2.y) * t], x2 = ref$[0], y2 = ref$[1];
      this.src.style.transform = "translate(" + x1 + "px," + y1 + "px)";
      this.des.style.transform = "translate(" + x2 + "px," + y2 + "px)";
      if (p < 1) {
        return requestAnimationFrame(function(it){
          return animate.handle(it);
        });
      }
      this.src.style.transform = "";
      this.des.style.transform = "";
      delete this.start;
      return this.running = false;
    }
  };
  reblock = function(opt){
    var root;
    opt == null && (opt = {});
    this.opt = opt;
    this.action = opt.action || {};
    this.reorder = {
      check: false
    };
    this.node = {
      editing: null,
      dragging: null,
      injecting: null
    };
    this.drag = {};
    this.selected = [];
    this.evtHandler = {};
    this.root = root = typeof opt.root === 'string'
      ? document.querySelector(opt.root)
      : opt.root;
    this.data = opt.data;
    this.blockmgr = opt.blockManager;
    this.init();
    this.ready = proxise(function(){});
    return this;
  };
  reblock.prototype = import$(Object.create(Object.prototype), {
    on: function(n, cb){
      var ref$;
      return ((ref$ = this.evtHandler)[n] || (ref$[n] = [])).push(cb);
    },
    fire: function(n){
      var v, i$, ref$, len$, cb, results$ = [];
      v = slice$.call(arguments, 1);
      for (i$ = 0, len$ = (ref$ = this.evtHandler[n] || []).length; i$ < len$; ++i$) {
        cb = ref$[i$];
        results$.push(cb.apply(this, v));
      }
      return results$;
    },
    init: function(){
      var this$ = this;
      document.addEventListener('click', function(e){
        var n, t;
        n = t = e.target;
        while (t && t !== this$.root) {
          t = t.parentNode;
        }
        if (!t) {
          return;
        }
        return this$.select(n.hasAttribute && (n.hasAttribute('repeat-item') || n.hasAttribute('block')) ? n : null);
      });
      this.root.addEventListener('dragover', function(e){
        var g, n, p, t;
        if (this$.node.dragging) {
          return;
        }
        g = !this$.node.injecting
          ? this$.node.injecting = document.createElement('div')
          : this$.node.injecting;
        g.classList.add('ghost');
        n = e.target;
        while (n && (p = n.parentNode)) {
          if (p.hasAttribute && p.hasAttribute('hostable')) {
            t = p;
            break;
          }
          if (n.hasAttribute && n.hasAttribute('hostable')) {
            t = n;
            break;
          } else {
            n = p;
          }
        }
        if (!t) {
          return;
        }
        if (t === n) {
          n = null;
        }
        if (t.childNodes.length && !n) {
          return;
        }
        if (n === g) {
          return;
        }
        if (g.parentNode) {
          g.parentNode.removeChild(g);
        }
        return t.insertBefore(g, n);
      });
      document.addEventListener('dragover', function(e){
        return e.preventDefault();
      });
      document.addEventListener('drop', function(e){
        var that, name;
        if (this$.node.dragging) {
          this$.node.dragging = null;
        }
        if (this$.node.injecting) {
          if (that = this$.node.injecting.parentNode) {
            that.removeChild(this$.node.injecting);
          }
          this$.node.injecting = null;
        }
        name = e.dataTransfer.getData('text/plain');
        if (!name) {
          return;
        }
        return this$.inject({
          node: e.target,
          name: name
        }).then(function(){
          e.preventDefault();
          return e.stopPropagation();
        })['catch'](function(it){
          return console.log(it);
        });
      });
      this.root.addEventListener('drop', function(){
        this$.reorder.check = 0;
        return this$.node.dragging = null;
      });
      this.root.addEventListener('dragstart', function(e){
        this$.node.dragging = e.target;
        return e.dataTransfer.setDragImage(ghost, 10, 10);
      });
      this.root.addEventListener('dragover', function(e){
        var src, des, isNext, ref$, sbox, dbox, x, y, dir, amount;
        e.preventDefault();
        if (!((src = this$.node.dragging) && (des = e.target))) {
          return;
        }
        if (!this$.action.beforeMove) {
          while (des) {
            if (des.parentNode === src.parentNode) {
              break;
            } else {
              des = des.parentNode;
            }
          }
        } else {
          des = this$.action.beforeMove(src, des);
        }
        if (!des || src === des) {
          return;
        }
        isNext = des === src.nextSibling;
        ref$ = [src.getBoundingClientRect(), des.getBoundingClientRect()], sbox = ref$[0], dbox = ref$[1];
        x = sbox.x === dbox.x
          ? 0
          : e.clientX - dbox.x;
        y = sbox.y === dbox.y
          ? 0
          : e.clientY - dbox.y;
        if (!this$.reorder.check) {
          ref$ = this$.reorder;
          ref$.x = e.clientX;
          ref$.y = e.clientY;
          ref$.check = 1;
        }
        dir = (x && e.clientX - this$.reorder.x > 0) || (y && e.clientY - this$.reorder.y > 0);
        amount = Math.abs(x
          ? e.clientX - this$.reorder.x
          : e.clientY - this$.reorder.y);
        if (amount < (x
          ? dbox.width
          : dbox.height) / 5) {
          return;
        }
        if (this$.action.moving) {
          des = this$.action.moving(src, des, dir);
        }
        this$.move(src, des, dir);
        if (this$.action.afterMove) {
          this$.action.afterMove(src, des, dir);
        }
        return this$.reorder.check = 0;
      });
      this.root.addEventListener('mousedown', function(e){
        var n, results$ = [];
        n = e.target;
        while (n) {
          if (n.hasAttribute && n.hasAttribute('repeat-item')) {
            break;
          } else {
            n = n.parentNode;
          }
        }
        if (!n) {
          return;
        }
        n.setAttribute('draggable', true);
        while (n = n.parentNode) {
          if (n.setAttribute) {
            results$.push(n.setAttribute('draggable', false));
          }
        }
        return results$;
      });
      this.root.addEventListener('click', function(e){
        return this$.edit(e.target);
      });
      this.root.addEventListener('keydown', function(e){
        var editables, idx, n;
        if (e.keyCode === 9) {
          if (!(e.target.hasAttribute && e.target.hasAttribute('editable'))) {
            return;
          }
          editables = Array.from(this$.root.querySelectorAll("[editable]"));
          idx = editables.indexOf(e.target) + (e.shiftKey ? -1 : 1);
          if (idx < 0 || !(n = editables[idx])) {
            n = e.target;
          }
          this$.edit(n);
          return e.preventDefault();
        }
      });
      return this.root.addEventListener('input', function(e){
        var n, name;
        if (!((n = e.target) && n.hasAttribute && (name = n.getAttribute('editable')))) {
          return;
        }
        if (this$.action.input) {
          return this$.action.input({
            node: n
          });
        }
      });
    },
    isDragging: function(){
      return !!this.node.dragging;
    },
    select: function(n, append){
      append == null && (append = false);
      this.selected.map(function(it){
        return it.removeAttribute('selected');
      });
      if (!append) {
        this.selected.splice(0, this.selected.length);
      }
      if (!n) {
        return;
      }
      if (!Array.isArray(n)) {
        n = [n];
      }
      this.selected = this.selected.concat(n);
      return n.map(function(it){
        return it.setAttribute('selected', true);
      });
    },
    edit: function(n){
      var type;
      if (!(n && n.hasAttribute && n.hasAttribute('editable'))) {
        return;
      }
      type = n.getAttribute('edit-type');
      if (type && !in$('text', type.split(' '))) {
        return;
      }
      if (this.node.editing) {
        this.node.editing.setAttribute('contenteditable', false);
      }
      this.node.editing = n;
      n.setAttribute('contenteditable', true);
      return n.focus();
    },
    clone: function(){
      var this$ = this;
      return this.select(this.selected.map(function(n){
        var m;
        n.parentNode.insertBefore(m = n.cloneNode(true), n.nextSibling);
        if (this$.action.clone) {
          this$.action.clone({
            node: m,
            src: n
          });
        }
        return m;
      }));
    },
    'delete': function(){
      var n, ref$, this$ = this;
      if (!(n = (ref$ = this.selected)[ref$.length - 1])) {
        return;
      }
      n = n.nextSibling || n.previousSibling;
      this.selected.map(function(it){
        if (this$.action['delete']) {
          this$.action['delete']({
            node: it
          });
        }
        return it.parentNode.removeChild(it);
      });
      return this.select(n);
    },
    move: function(src, des, after){
      var ib, ref$, p, ns, this$ = this;
      if (src === (ib = after ? des.nextSibling : des)) {
        return;
      }
      ref$ = [src.parentNode, src.nextSibling], p = ref$[0], ns = ref$[1];
      return animate.init({
        src: src,
        des: des,
        cb: function(){
          if (this$.action.beforeMoveNode) {
            this$.action.beforeMoveNode({
              src: src,
              des: des,
              ib: ib
            });
          }
          src.parentNode.removeChild(src);
          des.parentNode.insertBefore(src, ib);
          if (this$.action.afterMoveNode) {
            return this$.action.afterMoveNode({
              src: src,
              des: des,
              ib: ib
            });
          }
        }
      });
    },
    inject: function(arg$){
      var node, name, data, force, n, t, p, this$ = this;
      node = arg$.node, name = arg$.name, data = arg$.data, force = arg$.force;
      n = node;
      if (force) {
        t = n;
      } else {
        while (n && (p = n.parentNode)) {
          if (p.hasAttribute && p.hasAttribute('hostable')) {
            t = p;
            break;
          }
          if (n.hasAttribute && n.hasAttribute('hostable')) {
            t = n;
            break;
          } else {
            n = p;
          }
        }
        if (!t) {
          return Promise.reject(new Error(""));
        }
      }
      if (t === n) {
        n = null;
      }
      if (data && !name) {
        name = data.name;
      }
      if (this.action.beforeInject && this.action.beforeInject({
        name: name
      })) {
        return Promise.resolve();
      }
      return new Promise(function(res, rej){
        return this$.blockmgr.get(name).then(function(newNode){
          var s, h;
          t.insertBefore(newNode, n);
          if (this$.action.inject) {
            this$.action.inject({
              parent: t,
              node: newNode,
              sibling: n,
              data: data,
              name: name
            });
          }
          s = window.getComputedStyle(newNode);
          h = s.height;
          newNode.style.height = "0px";
          newNode.style.transition = "height .15s ease-in-out";
          setTimeout(function(){
            return newNode.style.height = h;
          }, 0);
          debounce(150).then(function(){
            newNode.style.transition = "";
            return newNode.style.height = "";
          });
          if (this$.action.afterInject) {
            return this$.action.afterInject({
              node: newNode,
              name: name
            });
          }
        }).then(function(){
          return res();
        })['catch'](function(it){
          return rej(it);
        });
      });
    }
  });
  reblock.ghost = ghost = new Image();
  ghost.src = "data:image/svg+xml," + encodeURIComponent("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"15\" viewBox=\"0 0 20 15\">\n  <rect x=\"0\" y=\"0\" width=\"20\" height=\"15\" fill=\"rgba(0,0,0,.5)\"/>\n</svg>");
  if (typeof window != 'undefined' && window !== null) {
    window.reblock = reblock;
  }
  if (typeof module != 'undefined' && module !== null) {
    return module.exports = reblock;
  }
})();
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}