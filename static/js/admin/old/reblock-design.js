// Generated by LiveScript 1.3.0
var reblockDesign;
reblockDesign = {
  apply: function(ops){
    return otJson0.type.apply(this.data, ops[0]);
  },
  submit: function(ops){
    console.log(ops);
    return console.log(this.data);
  },
  watch: function(ops){},
  getHost: function(v){
    var i$, i, bind;
    if (typeof v === 'string') {
      v = (this.getBind(v) || {}).node;
    }
    for (i$ = 0; i$ < 100; ++i$) {
      i = i$;
      if (!v) {
        return null;
      }
      bind = this.getBind(v);
      if (bind) {
        if (bind.block) {
          return bind;
        }
        if (bind.host) {
          return bind.host;
        }
      }
      v = v.parentNode;
    }
  },
  getBind: function(v){
    if (typeof v === 'string') {
      return this.binding[v];
    } else if (v.reblock) {
      return this.binding[v.reblock.id];
    }
    return null;
  },
  bind: function(arg$){
    var node, data, block, id, host;
    node = arg$.node, data = arg$.data, block = arg$.block;
    id = node.reblock && node.reblock.id
      ? id
      : data.id || Math.random().toString(36).substring(2);
    if (!data.id) {
      data.id = id;
    }
    host = this.getHost(node.parentNode);
    this.binding[data.id] = {
      node: node,
      data: data,
      host: host,
      block: block
    };
    if (node.setAttribute) {
      node.setAttribute('rbid', data.id);
    }
    return (node.reblock || (node.reblock = {})).id = data.id;
  },
  inject: function(arg$){
    var host, sibling, dir, name, data, recurse, block, ns, retval, this$ = this;
    host = arg$.host, sibling = arg$.sibling, dir = arg$.dir, name = arg$.name, data = arg$.data, recurse = arg$.recurse, block = arg$.block;
    if (!data) {
      data = {
        type: 'block',
        name: name,
        data: {}
      };
    }
    if (!name) {
      name = data.name;
    }
    if (sibling) {
      if (!host) {
        host = ld$.parent(sibling, '[editable]');
      }
      ns = ld$.parent(sibling, '[editable] > *', host);
    }
    retval = {
      data: data
    };
    return new Promise(function(res, rej){
      var promise;
      if (data.type !== 'block') {
        return rej(new Error("incorrect data type"));
      }
      promise = !name
        ? Promise.resolve("<div editable=\"blocks\"></div>")
        : /^int:/.exec(name)
          ? Promise.resolve(block.subblock[name])
          : this$.blockmgr.get(name);
      return promise.then(function(blockData){
        var node, s, h, x$, block, hostbind, idx, ref$, key$;
        if (typeof blockData === 'string') {
          retval.node = node = document.createElement("div");
          node.innerHTML = blockData;
          if (node.childNodes.length === 1) {
            node = node.childNodes[0];
            node.parentNode.removeChild(node);
          }
        } else if (blockData instanceof Element) {
          retval.node = node = blockData.cloneNode(true);
        } else {
          Promise.reject(new Error("unrecognized block data"));
        }
        if (host) {
          host.insertBefore(node, ns);
        }
        if (!recurse && this$.opt.transition) {
          s = window.getComputedStyle(node);
          h = s.height;
          x$ = node.style;
          x$.height = "0px";
          x$.transition = "height .15s ease-in-out";
          setTimeout(function(){
            return node.style.height = h;
          }, 0);
          debounce(150).then(function(){
            node.style.transition = "";
            return node.style.height = "";
          });
        }
        this$.bind({
          node: node,
          data: data,
          block: true
        });
        block = this$.prepare({
          node: node,
          data: data
        });
        this$.construct({
          node: node,
          data: data,
          block: block
        });
        hostbind = this$.getHost(host);
        if (!recurse && hostbind) {
          idx = Array.from(host.childNodes).indexOf(node);
          return ((ref$ = hostbind.data.data)[key$ = host.getAttribute('editable')] || (ref$[key$] = [])).splice(idx, 0, data);
        }
      }).then(function(){
        return res(retval);
      })['catch'](function(it){
        return rej(it);
      });
    });
  },
  prepare: function(arg$){
    var node, data, block, excludes, blocks;
    node = arg$.node, data = arg$.data;
    block = {};
    excludes = ld$.find(node, "[rbid='" + data.id + "'] [block] [block]");
    blocks = ld$.find(node, "[block]").filter(function(it){
      return !in$(it, excludes);
    }).map(function(it){
      var name;
      name = it.getAttribute('block');
      (block.subblock || (block.subblock = {}))["int:" + name] = it;
      return it.parentNode.removeChild(it);
    });
    return block;
  },
  construct: function(arg$){
    var node, data, block, recurse, this$ = this;
    node = arg$.node, data = arg$.data, block = arg$.block, recurse = arg$.recurse;
    return new Promise(function(res, rej){
      var nodes, excludes, vars, promises;
      nodes = ld$.find(node, "[editable]");
      excludes = ld$.find(node, "[rbid='" + data.id + "'] [editable] [editable]");
      nodes = nodes.filter(function(it){
        return !in$(it, excludes);
      });
      vars = data.data;
      promises = nodes.map(function(n){
        var name, val, ps;
        name = n.getAttribute('editable');
        if (!n.getAttribute('edit-type')) {
          n.innerHTML = "";
        }
        if (!Array.isArray(val = vars[name] || {})) {
          val = [val];
        }
        ps = val.map(function(v){
          if (v.type === 'text') {
            Promise.resolve(n.appendChild(document.createTextNode(v.value)));
            return this$.bind({
              node: n,
              data: v
            });
          } else if (v.type === 'block') {
            return this$.inject({
              host: n,
              data: v,
              recurse: true,
              block: block
            });
          }
        });
        return Promise.all(ps);
      });
      return Promise.all(promises).then(function(){
        return res();
      }).then(function(){
        return rej();
      });
    });
  }
};
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}