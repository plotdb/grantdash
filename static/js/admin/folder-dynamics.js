// Generated by LiveScript 1.3.0
var folderData, backup, apply, root, itemSample, folderSample, render, path, host, rebind, reb;
folderData = [{
  name: "歷屆活動",
  toggle: true,
  children: [
    {
      name: "2018春季"
    }, {
      name: "2018秋季"
    }
  ]
}];
backup = JSON.parse(JSON.stringify(folderData));
apply = function(ops){
  console.log(JSON.stringify(ops), JSON.stringify(backup));
  otJson0.type.apply(backup, ops);
  return console.log("result: ", JSON.stringify(backup));
};
root = ld$.find('#root', 0);
itemSample = ld$.find('#item-sample', 0);
folderSample = ld$.find('#folder-sample', 0);
itemSample.removeAttribute('id');
folderSample.removeAttribute('id');
render = function(data, root){
  return data.map(function(item){
    var itemNode, folderNode;
    itemNode = itemSample.cloneNode(true);
    ld$.find(itemNode, '[name=name]', 0).value = item.name || '';
    ld$.find(itemNode, '[name=url]', 0).value = item.url || '';
    itemNode.data = item;
    if (item.children) {
      itemNode.classList.add('folder-toggle');
      itemNode.removeAttribute('draggable');
      folderNode = folderSample.cloneNode(true);
      folderNode.data = item;
      folderNode.insertBefore(itemNode, folderNode.childNodes[0]);
      root.appendChild(folderNode);
      return render(item.children, ld$.find(folderNode, '.folder-menu', 0));
    } else {
      return root.appendChild(itemNode);
    }
  });
};
render(folderData, root);
path = function(node){
  var path, pdata, list, idx;
  path = [];
  for (;;) {
    pdata = host(node).data;
    list = pdata.children || pdata;
    idx = list.indexOf(node.data);
    path = (pdata.children
      ? ['children']
      : []).concat([idx], path);
    while (node) {
      node = node.parentNode;
      if (node === root || node.data) {
        break;
      }
    }
    if (!node || !node.data) {
      break;
    }
  }
  return path;
};
host = function(n){
  while (n) {
    n = n.parentNode;
    if (n === root || !n || n.data) {
      break;
    }
  }
  return {
    node: n,
    data: n && n.data ? n.data : folderData
  };
};
root.addEventListener('input', function(e){
  var n, ref$, node, data, k, v, o, ops;
  if (!((n = e.target) && n.getAttribute)) {
    return;
  }
  ref$ = host(n), node = ref$.node, data = ref$.data;
  ref$ = [n.getAttribute('name'), n.value], k = ref$[0], v = ref$[1];
  o = data[k];
  data[k] = v;
  ops = [import$({
    p: path(node).concat([k]),
    oi: v
  }, o
    ? {
      od: o
    }
    : {})];
  console.log(ops);
  return apply(ops);
});
rebind = function(node, data){
  node.data = data;
  if (node.classList.contains('folder')) {
    return Array.from(ld$.find(node, '.folder-menu', 0).childNodes).map(function(d, i){
      return rebind(d, data.children[i]);
    });
  }
};
reb = new reblock({
  root: '#root',
  action: {
    beforeMoveNode: function(arg$){
      var src, des, ib, p, pdata, ops;
      src = arg$.src, des = arg$.des, ib = arg$.ib;
      p = path(src);
      pdata = host(src).data;
      pdata = pdata.children || pdata;
      pdata.splice(pdata.indexOf(src), 1);
      ops = [{
        p: p,
        ld: src.data
      }];
      console.log(")", p, src.data);
      return apply(ops);
    },
    afterMoveNode: function(arg$){
      var src, des, ib, ref$, node, data, idx, p, ops;
      src = arg$.src, des = arg$.des, ib = arg$.ib;
      ref$ = host(src), node = ref$.node, data = ref$.data;
      console.log(data);
      idx = ib
        ? Array.from(des.childNodes).indexOf(ib)
        : des.childNodes.length;
      console.log(idx);
      (data.children || data).splice(idx, 0, src.data);
      p = path(src);
      p[p.length - 1] = idx;
      ops = [{
        p: p,
        li: src.data
      }];
      return apply(ops);
    },
    clone: function(arg$){
      var node, src, data, p, pdata, ops;
      node = arg$.node, src = arg$.src;
      data = JSON.parse(JSON.stringify(src.data));
      rebind(node, data);
      p = path(src);
      p[p.length - 1] += 1;
      pdata = host(node).data;
      (pdata.children || pdata).splice(p[p.length - 1], 0, data);
      node.data = data;
      ops = [{
        p: p,
        li: data
      }];
      return apply(ops);
    },
    'delete': function(arg$){
      var node, pdata, p, list, idx, ops;
      node = arg$.node;
      pdata = host(node).data;
      p = path(node);
      list = pdata.children || pdata;
      idx = list.indexOf(node.data);
      list.splice(idx, 1);
      ops = [{
        p: p,
        ld: node.data
      }];
      return apply(ops);
    },
    input: function(){},
    beforeMove: function(src, des){
      var n;
      if (des.classList.contains('folder')) {
        return null;
      }
      while (des) {
        if (!des.parentNode.classList) {
          return null;
        }
        if (des.classList.contains('folder-toggle')) {
          if (src === des.parentNode) {
            return null;
          }
          if (n = ld$.find(des.parentNode, '.folder-menu', 0)) {
            n.insertBefore(des = document.createElement('div'), n.childNodes[0]);
            des.dummy = true;
            break;
          }
        }
        if (des.parentNode.classList.contains('folder-menu') || des.parentNode.classList.contains('folder-root')) {
          break;
        }
        if (des.parentNode === src.parentNode) {
          break;
        } else {
          des = des.parentNode;
        }
      }
      if (!des || src === des || ld$.parent(des, null, src)) {
        if (des.dummy) {
          des.parentNode.removeChild(des);
        }
        return null;
      }
      return des;
    },
    moving: function(src, des, dir){
      var d;
      if (dir === 0 && des.dummy) {
        d = des;
        des = des.parentNode.parentNode;
        d.parentNode.removeChild(d);
      }
      return des;
    },
    afterMove: function(src, des, dir){
      if (des.dummy) {
        return des.parentNode.removeChild(des);
      }
    }
  }
});
root = ld$.find('#root', 0);
root.addEventListener('click', function(e){
  var n, f, old, pdata, list, idx, ops, fp, fn, m, ms;
  if (!e.target.classList) {
    return;
  }
  if (!(n = ld$.parent(e.target, '.folder-item', root))) {
    return;
  }
  if (e.target.classList.contains('i-close')) {
    if (n.parentNode.classList.contains('folder')) {
      n = n.parentNode;
    }
    reb.select(n);
    return reb['delete']();
  } else if (e.target.classList.contains('i-clone')) {
    if (n.parentNode.classList.contains('folder')) {
      n = n.parentNode;
    }
    reb.select(n);
    reb.clone();
    if (n.classList.contains('folder')) {
      return new ldui.Folder({
        root: n
      });
    }
  } else if (e.target.classList.contains('i-radio')) {
    if (n.classList.contains('folder-toggle')) {
      n.classList.remove('folder-toggle');
      n.setAttribute('draggable', true);
      f = n.parentNode;
      old = JSON.parse(JSON.stringify(folderData));
      n.data = f.data;
      pdata = host(f).data;
      list = pdata.children || pdata;
      idx = list.indexOf(n.data) + 1;
      list.splice.apply(list, [idx, 0].concat(n.data.children));
      delete n.data.children;
      delete n.data.toggle;
      ops = json0OtDiff(old, folderData);
      apply(ops);
      fp = f.parentNode;
      fn = f.nextSibling;
      m = ld$.find(f, '.folder-menu', 0);
      ms = ld$.find(f, '.folder-menu > .folder-item');
      ms.map(function(it){
        it.parentNode.removeChild(it);
        return fp.insertBefore(it, fn);
      });
      m.parentNode.removeChild(m);
      f.removeChild(n);
      fp.insertBefore(n, f);
      return fp.removeChild(f);
    } else {
      n.classList.add('folder-toggle');
      f = ld$.create({
        name: 'div',
        className: ['folder', 'show'],
        attr: {
          draggable: "true"
        }
      });
      m = ld$.create({
        name: 'div',
        className: ['folder-menu']
      });
      n.removeAttribute('draggable');
      n.parentNode.insertBefore(f, n);
      n.parentNode.removeChild(n);
      f.appendChild(n);
      f.appendChild(m);
      return new ldui.Folder({
        root: f
      });
    }
  }
});
reb.init();
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}