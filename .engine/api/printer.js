// Generated by LiveScript 1.3.0
(function(){
  var fs, fsExtra, path, lderror, puppeteer, tmp, easyPdfMerge, tmpfn, Printer;
  fs = require('fs');
  fsExtra = require('fs-extra');
  path = require('path');
  lderror = require('lderror');
  puppeteer = require('puppeteer');
  tmp = require('tmp');
  easyPdfMerge = require('easy-pdf-merge');
  tmpfn = function(){
    return new Promise(function(res, rej){
      return tmp.file(function(err, path, fd, cb){
        if (err) {
          return rej(err);
        }
        return res({
          fn: path,
          clean: cb
        });
      });
    });
  };
  Printer = function(opt){
    var ref$;
    opt == null && (opt = {});
    this.opt = opt;
    this.count = (ref$ = opt.count || 4) < 20 ? ref$ : 20;
    this.queue = [];
    return this;
  };
  Printer.get = function(){
    if (this._printer) {
      return this._printer;
    }
    this._printer = new Printer({
      count: 15
    });
    this._printer.init();
    return this._printer;
  };
  Printer.prototype = import$(Object.create(Object.prototype), {
    exec: function(cb){
      var lc, _, this$ = this;
      lc = {
        trial: 0
      };
      _ = function(){
        return this$.get().then(function(obj){
          return lc.obj = obj;
        }).then(function(){
          return cb(lc.obj.page);
        }).then(function(it){
          return lc.ret = it;
        })['catch'](function(){
          if ((lc.trial++) > 5) {
            return Promise.reject(new lderror(0));
          }
          return this$.respawn(lc.obj).then(function(){
            return _();
          });
        }).then(function(){
          return this$.free(lc.obj);
        }).then(function(){
          return lc.ret;
        });
      };
      return _();
    },
    merge: function(payload){
      var this$ = this;
      payload == null && (payload = {});
      return Promise.resolve().then(function(){
        if (!payload.html) {
          return null;
        }
        return this$.print({
          html: payload.html
        }).then(function(buf){
          return tmpfn().then(function(arg$){
            var fn;
            fn = arg$.fn;
            return new Promise(function(res, rej){
              return fs.writeFile(fn, buf, function(e){
                if (e) {
                  return rej(new Error(e));
                }
                return res(fn);
              });
            });
          });
        });
      }).then(function(formFn){
        if (!payload.files || payload.files.length < 1 || (payload.files.length === 1 && !formFn)) {
          return Promise.reject(new lderror(400));
        }
        return new Promise(function(res, rej){
          return easyPdfMerge((formFn
            ? [formFn]
            : []).concat(payload.files), payload.outfile, function(e){
            if (e) {
              return rej(e);
            }
            return res(payload.outfile);
          });
        });
      });
    },
    print: function(payload){
      payload == null && (payload = {});
      return this.exec(function(page){
        var p;
        p = payload.html
          ? page.setContent(payload.html, {
            waitUntil: "networkidle0"
          })
          : payload.url
            ? page.goto(payload.url)
            : Promise.reject(new ldError(1015));
        return p.then(function(){
          return page.pdf({
            format: 'A4'
          });
        });
      });
    },
    get: function(){
      var this$ = this;
      return new Promise(function(res, rej){
        var i$, to$, i;
        for (i$ = 0, to$ = this$.pages.length; i$ < to$; ++i$) {
          i = i$;
          if (!this$.pages[i].busy) {
            this$.pages[i].busy = true;
            return res(this$.pages[i]);
          }
        }
        return this$.queue.push({
          res: res,
          rej: rej
        });
      });
    },
    free: function(obj){
      var ret;
      if (this.queue.length) {
        ret = this.queue.splice(0, 1)[0];
        return ret.res(obj);
      } else {
        return obj.busy = false;
      }
    },
    respawn: function(obj){
      var this$ = this;
      return Promise.resolve().then(function(){
        if (!obj.page.isClosed()) {
          return page.close();
        }
      })['catch'](function(){}).then(function(){
        return Printer.browser.newPage();
      }).then(function(page){
        return obj.page = page;
      });
    },
    init: function(){
      var that, this$ = this;
      return ((that = Printer.browser)
        ? Promise.resolve(that)
        : puppeteer.launch({
          headless: true,
          args: ['--no-sandbox']
        })).then(function(browser){
        var i;
        Printer.browser = browser;
        return Promise.all((function(){
          var i$, to$, results$ = [];
          for (i$ = 0, to$ = this.count; i$ < to$; ++i$) {
            i = i$;
            results$.push(browser.newPage().then(fn$));
          }
          return results$;
          function fn$(it){
            return {
              busy: false,
              page: it
            };
          }
        }.call(this$)));
      }).then(function(it){
        return this$.pages = it;
      });
    }
  });
  module.exports = Printer;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
