// Generated by LiveScript 1.3.0
(function(){
  var permcheck, lderror, aux, codedDomains, route, perm, stage;
  permcheck = require('permcheck');
  lderror = require('lderror');
  aux = require('../aux');
  codedDomains = {
    "grantdash.dev": {
      org: "grantdash-dev",
      orgname: "Grant Dash Dev"
    },
    "dev.grantdash.dev": {
      org: "grantdash-dev",
      orgname: "Grant Dash Dev"
    },
    "dev.gda.sh": {
      org: "grantdash-dev",
      orgname: "Grant Dash Dev"
    },
    "grantdash.io": {
      orgname: "Grant Dash"
    },
    "taicca.grantdash.io": {
      org: "taicca-tw",
      brd: "grantdash-test",
      orgname: "Taicca Dash"
    },
    "sch001.g0v.tw": {
      org: "g0v-jothon",
      brd: "sch001",
      orgname: "零時小學校"
    },
    "dash.taicca.tw": {
      org: "taicca-tw",
      orgname: "文化內容策進院"
    }
  };
  route = {
    cache: {
      domain: codedDomains || {},
      brd: {},
      prj: {}
    },
    check: function(arg$){
      var io, req, res, this$ = this;
      io = arg$.io, req = arg$.req, res = arg$.res;
      return Promise.resolve().then(function(){
        var domain, paths, ret, brd, prj, promise, that;
        domain = req.get("host");
        paths = /api/.exec(req.originalUrl)
          ? [req.get('Referrer'), req.originalUrl]
          : [req.originalUrl];
        ret = paths.map(function(pathname){
          var brd, prj;
          if (brd = /brd\/([^/?]+)/.exec(pathname)) {
            brd = brd[1];
          }
          if (prj = /prj\/([^/?]+)/.exec(pathname)) {
            prj = prj[1];
          }
          return {
            brd: brd,
            prj: prj
          };
        });
        brd = ret[0].brd || (ret[1] ? ret[1].brd : null);
        prj = ret[0].prj || (ret[1] ? ret[1].prj : null);
        promise = brd
          ? (that = this$.cache.brd[brd])
            ? Promise.resolve(that)
            : io.query("select b.org, b.name as brdname\nfrom brd as b\nwhere b.slug = $1 and b.deleted is not true", [brd]).then(function(r){
              var ref$;
              r == null && (r = {});
              return this$.cache.brd[brd] = (ref$ = (r.rows || (r.rows = []))[0] || {}, ref$.brd = brd, ref$);
            })
          : prj
            ? (that = this$.cache.prj[prj])
              ? Promise.resolve(that)
              : io.query("select p.brd, b.org, b.name as brdname\nfrom prj as p, brd as b\nwhere b.slug = p.brd and p.slug = $1 and p.deleted is not true and b.deleted is not true", [prj]).then(function(r){
                r == null && (r = {});
                return this$.cache.prj[prj] = (r.rows || (r.rows = []))[0] || {};
              })
            : Promise.resolve(null);
        return promise.then(function(pathCfg){
          var p, that;
          if (pathCfg && !pathCfg.org) {
            return Promise.reject(new lderror(1019));
          }
          p = (that = this$.cache.domain[domain])
            ? Promise.resolve(that)
            : Promise.reject(new lderror(1019));
          return p.then(function(domainCfg){
            var ret, ref$;
            if (!domainCfg) {
              return Promise.reject(new lderror(1019));
            }
            if (!pathCfg) {
              return domainCfg.domain = domain, domainCfg;
            }
            if ((pathCfg.org !== domainCfg.org || (domainCfg.brd && domainCfg.brd !== pathCfg.brd)) && domainCfg.org) {
              return Promise.reject(new lderror(1019));
            }
            ret = (ref$ = (pathCfg.orgname = domainCfg.orgname, pathCfg), ref$.domain = domain, ref$);
            return ref$ = (pathCfg.orgname = domainCfg.orgname, pathCfg), ref$.domain = domain, ref$;
          });
        });
      });
    }
  };
  perm = {
    cache: {},
    cachePrj: {},
    cacheJudge: {
      brd: {}
    },
    perm: {},
    supportedTypes: ['org', 'brd', 'prj', 'post', 'form'],
    invalidateJudge: function(arg$){
      var type, slug, ref$;
      type = arg$.type, slug = arg$.slug;
      return ((ref$ = this.cacheJudge)[type] || (ref$[type] = {}))[slug] = {};
    },
    invalidate: function(arg$){
      var type, slug, ref$;
      type = arg$.type, slug = arg$.slug;
      ((ref$ = this.cache)[type] || (ref$[type] = {}))[slug] = {};
      ((ref$ = this.perm)[type] || (ref$[type] = {}))[slug] = null;
      return ((ref$ = this.cacheJudge)[type] || (ref$[type] = {}))[slug] = {};
    },
    check: function(arg$){
      var io, user, type, slug, action, payload, this$ = this;
      io = arg$.io, user = arg$.user, type = arg$.type, slug = arg$.slug, action = arg$.action;
      action = Array.isArray(action)
        ? action
        : [action];
      payload = {
        role: {},
        perm: {}
      };
      return Promise.resolve().then(function(){
        var ref$, ref1$, p, that;
        if (!(user && user.key && slug && in$(type, this$.supportedTypes))) {
          return Promise.reject();
        }
        if (user.staff === 1) {
          return true;
        }
        if (((ref$ = (ref1$ = this$.cache)[type] || (ref1$[type] = {}))[slug] || (ref$[slug] = {}))[user.key] != null) {
          return this$.cache[type][slug][user.key]
            ? true
            : Promise.reject();
        }
        p = (that = ((ref$ = this$.perm)[type] || (ref$[type] = {}))[slug])
          ? Promise.resolve(that)
          : io.query("select owner, detail->'perm' as perm from " + type + " where slug = $1", [slug]).then(function(r){
            var ret, ref$;
            r == null && (r = {});
            if (!(ret = (r.rows || (r.rows = []))[0])) {
              return Promise.reject();
            }
            return ((ref$ = this$.perm)[type] || (ref$[type] = {}))[slug] = ret;
          });
        return p.then(function(ret){
          var ref$;
          if (user.key === ret.owner) {
            return;
          }
          payload.perm = (ref$ = ret.perm || (ret.perm = {})).roles || (ref$.roles = []);
          return io.query("select ref from perm where owner = $1 and objtype = $2 and objslug = $3 and type = 'token'", [user.key, type, slug]).then(function(r){
            var token;
            r == null && (r = {});
            token = (r.rows || (r.rows = [])).map(function(it){
              return it.ref;
            });
            payload.role = {
              user: [user.key],
              email: [user.username],
              token: token
            };
            return permcheck(payload);
          }).then(function(cfg){
            if (!cfg || !action.filter(function(it){
              return cfg[it];
            }).length) {
              return Promise.reject();
            }
          });
        });
      }).then(function(){
        var ref$, ref1$;
        return ((ref$ = (ref1$ = this$.cache)[type] || (ref1$[type] = {}))[slug] || (ref$[slug] = {}))[user.key] = true;
      })['catch'](function(e){
        var ref$, ref1$;
        if (user && user.key && !e) {
          ((ref$ = (ref1$ = this$.cache)[type] || (ref1$[type] = {}))[slug] || (ref$[slug] = {}))[user.key] = false;
        }
        if (e && e.id !== 1012) {
          console.log("[sharedb access error]", e);
        }
        return Promise.reject(e || new lderror(1012));
      });
    },
    checkJudge: function(arg$){
      var io, brd, grp, user, v, ref$, ref1$, this$ = this;
      io = arg$.io, brd = arg$.brd, grp = arg$.grp, user = arg$.user;
      v = ((ref$ = (ref1$ = this.cacheJudge.brd)[brd] || (ref1$[brd] = {}))[grp] || (ref$[grp] = {}))[user.key];
      if (v != null) {
        return v
          ? Promise.resolve(true)
          : Promise.reject(new lderror(1012));
      }
      return io.query("select key from perm_judge where brd = $1 and grp = $2 and owner = $3", [brd, grp, user.key]).then(function(r){
        var ref$, ref1$;
        r == null && (r = {});
        if (!(r.rows || (r.rows = [])).length) {
          ((ref$ = (ref1$ = this$.cacheJudge.brd)[brd] || (ref1$[brd] = {}))[grp] || (ref$[grp] = {}))[user.key] = false;
          return Promise.reject(new lderror(1012));
        }
        return ((ref$ = (ref1$ = this$.cacheJudge.brd)[brd] || (ref1$[brd] = {}))[grp] || (ref$[grp] = {}))[user.key] = true;
      });
    },
    sharedb: function(arg$){
      var io, user, id, data, type, action, ids, ref$, slug, this$ = this;
      io = arg$.io, user = arg$.user, id = arg$.id, data = arg$.data, type = arg$.type, action = arg$.action;
      if (!id) {
        return Promise.resolve();
      }
      ref$ = ids = id.split('/'), type = ref$[0], slug = ref$[1];
      return this.check({
        io: io,
        user: user,
        type: type,
        slug: slug,
        action: action
      })['catch'](function(it){
        var p, that, ret;
        if (type === 'prj') {
          p = (that = this$.cachePrj[slug]) != null
            ? Promise.resolve(that)
            : io.query("select brd from prj where slug = $1", [slug]).then(function(r){
              r == null && (r = {});
              return (r.rows || (r.rows = []))[0];
            });
          ret = p.then(function(prj){
            if (!prj) {
              return Promise.reject(new lderror(1012));
            }
            this$.cachePrj[slug] = prj;
            return this$.check({
              io: io,
              user: user,
              type: 'brd',
              slug: prj.brd,
              action: ['owner']
            });
          });
          return ret;
        }
        if (!(type === 'brd' && ids[2] === 'grp' && ids[4] === 'judge')) {
          return Promise.reject(it);
        }
        return this$.checkJudge({
          io: io,
          brd: ids[1],
          grp: ids[3],
          user: user
        });
      });
    }
  };
  stage = {
    cache: {},
    supportedTypes: ['brd'],
    invalidate: function(arg$){
      var type, slug, ref$;
      type = arg$.type, slug = arg$.slug;
      return ((ref$ = this.cache)[type] || (ref$[type] = {}))[slug] = null;
    },
    check: function(arg$){
      var io, type, slug, name, this$ = this;
      io = arg$.io, type = arg$.type, slug = arg$.slug, name = arg$.name;
      return Promise.resolve().then(function(){
        var that, ref$;
        if (in$(!type, this$.supportedTypes)) {
          return aux.reject(400);
        }
        if (!slug) {
          return aux.reject(400);
        }
        if (that = ((ref$ = this$.cache)[type] || (ref$[type] = {}))[slug]) {
          return that;
        }
        return io.query("select detail->'stage' as stage from brd where slug = $1 and deleted is not true", [slug]).then(function(r){
          var ret, stage, cfgs, ref$, idx, value, i$, to$, i, v, that;
          r == null && (r = {});
          if (!(ret = (r.rows || (r.rows = []))[0])) {
            return aux.reject(404);
          }
          stage = (ret.stage || (ret.stage = {})).list || [];
          cfgs = stage.filter(function(s){
            if (s.start && Date.now() < new Date(s.start).getTime()) {
              return false;
            }
            if (s.end && Date.now() > new Date(s.end).getTime()) {
              return false;
            }
            return true;
          });
          ref$ = [0, 0], idx = ref$[0], value = ref$[1];
          for (i$ = 0, to$ = cfgs.length; i$ < to$; ++i$) {
            i = i$;
            v = (that = cfgs[i].start) ? Date.now() - new Date(that).getTime() : 0;
            if (!value || (v <= value && v > 0)) {
              ref$ = [i, v], idx = ref$[0], value = ref$[1];
            }
          }
          ret = cfgs[idx] || {};
          if (!ret.config) {
            ret.config = {};
          }
          return this$.cache[type][slug] = ret;
        });
      }).then(function(c){
        if (!name) {
          return c;
        }
        if (!c.config[name]) {
          return Promise.reject(new lderror(1012));
        }
        return true;
      });
    }
  };
  module.exports = {
    perm: perm,
    stage: stage,
    route: route
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
